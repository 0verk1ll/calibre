# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>

from dom import clear
from encodings import base64decode, utf8_decode

JSON_XHTML_MIMETYPE = 'application/calibre+xhtml+json'

def decode_component(x):
    return utf8_decode(base64decode(x))

def decode_url(x):
    parts = x.split('#', 1)
    return decode_component(parts[0]), parts[1] or ''

def create_link_pat(book):
    return RegExp(book.manifest.link_uid + r'\|([^|]+)\|', 'g')

def load_resources(db, book, root_name, previous_resources, proceed):
    ans = {}
    pending_resources = v'[root_name]'
    link_pat = create_link_pat(book)

    def do_one():
        if not pending_resources.length:
            for k in previous_resources:
                v'delete previous_resources[k]'
            proceed(ans)
            return
        name = pending_resources.shift()
        if name in ans:
            return setTimeout(do_one, 0)
        if name in previous_resources:
            ans[name] = data = previous_resources[name]
            if type(data) is 'string':
                find_virtualized_resources(data)
            return setTimeout(do_one, 0)
        db.get_file(book, name, got_one)

    def got_one(data, name, mimetype):
        if name is book.manifest.title_page_name:
            w = book.manifest.cover_width or 600
            h = book.manifest.cover_height or 800
            ar = 'xMidYMid meet' # or 'none'
            data = str.replace(data, '__ar__', ar)
            data = str.replace(data, '__viewbox__', '0 0 ' + w + ' ' + h)
            data = str.replace(data, '__width__', w + '')
            data = str.replace(data, '__height__', h + '')
        ans[name] = v'[data, mimetype]'
        if type(data) is 'string':
            find_virtualized_resources(data)
        return setTimeout(do_one, 0)

    def find_virtualized_resources(text):
        seen = set()
        already_pending = {x.name for x in pending_resources}
        while True:
            m = link_pat.exec(text)
            if not m:
                break
            name = decode_url(m[1])[0]
            if name in seen or name in already_pending:
                continue
            seen.add(name)
            pending_resources.push(name)

    do_one()

def finalize_resources(book, root_name, resource_data):
    blob_url_map = {}
    root_data = None
    link_pat = create_link_pat(book)

    # Resolve the non virtualized resources immediately
    for name in resource_data:
        data, mimetype = resource_data[name]
        if type(data) is not 'string':
            blob_url_map[name] = window.URL.createObjectURL(data)
    for name in blob_url_map:
        v'delete resource_data[name]'

    def add_virtualized_resource(name, text, mimetype):
        nonlocal root_data
        if name is root_name:
            root_data = JSON.parse(text)
        else:
            blob_url_map[name] = window.URL.createObjectURL(Blob([text], {'type': mimetype}))

    def replace_deps(text):
        replacements = v'[]'
        unresolved_deps = set()
        while True:
            m = link_pat.exec(text)
            if not m:
                break
            dname, frag = decode_url(m[1])
            if dname in blob_url_map:
                rtext = blob_url_map[dname]
                if frag:
                    rtext += '#' + frag
                replacements.push(v'[m.index, m[0].length, rtext]')
            elif unresolved_deps:
                unresolved_deps.add(dname)
        for index, sz, repl in reversed(replacements):
            text = text[:index] + repl + text[index + sz:]
        return unresolved_deps, text

    unresolved_deps_map = {}

    def has_unresolvable_deps(name):
        deps = unresolved_deps_map[name]
        if not deps or not deps.length:
            return False
        deps = [x for x in deps if x not in blob_url_map]
        return deps.length > 0

    while True:
        resolved = v'[]'
        num = 0
        for name in resource_data:
            if name not in blob_url_map:
                num += 1
                text, mimetype = resource_data[name]
                if not has_unresolvable_deps(name):
                    unresolved_deps, text = replace_deps(text)
                    unresolved_deps_map[name] = unresolved_deps
                    if not unresolved_deps.length:
                        add_virtualized_resource(name, text, mimetype)
                        resolved.push(name)
        if not num:
            break
        if not resolved.length:
            unresolved = [name for name in resource_data if name not in blob_url_map]
            print(str.format('ERROR: Could not resolve all dependencies of {} because of a cyclic dependency. Remaining deps: {}', root_name, unresolved))
            # Add the items anyway, without resolving remaining deps
            for name in resource_data:
                if name not in blob_url_map:
                    text, mimetype = resource_data[name]
                    text = replace_deps(text)[1]
                    add_virtualized_resource(name, text, mimetype)
            break
        for name in resolved:
            v'delete resource_data[name]'

    return root_data

js_types = set('text/javascript text/ecmascript application/javascript application/ecmascript'.split(' '))
resource_tag_names = {'script':'src', 'link':'href', 'img':'src', 'image':'xlink:href'}

def apply_attributes(src, elem, ns_map):
    attributes = src.a
    if not attributes:
        return
    for a in attributes:
        if a[2]:
            elem.setAttributeNS(ns_map[a[2]], a[0], a[1])
        else:
            elem.setAttribute(a[0], a[1])

def process_stack(stack, tag_map, ns_map, load_required, onload):
    while stack.length:
        node, parent = stack.pop()
        src = tag_map[node[0]]
        if src.s:
            elem = document.createElementNS(ns_map[src.s], src.n)
        else:
            elem = document.createElement(src.n)
        loadable = False
        if src.n in resource_tag_names:
            attr = resource_tag_names[src.n]
            if attr.indexOf(':') != -1:
                attr = attr.replace('xlink:', '')
            for a in (src.a or v'[]'):
                if a[0] is attr:
                    loadable = str.startswith(a[1], 'blob:')
                    break
        if loadable:
            load_required.add(node[0])
            elem.addEventListener('load', onload.bind(node[0]))
            elem.addEventListener('error', onload.bind(node[0]))

        apply_attributes(src, elem, ns_map)
        parent.appendChild(elem)
        if src.x:
            if src.n is 'script' and (elem.getAttribute('type') or 'text/javascript').toLowerCase() in js_types:
                elem.text = src.x
            else:
                elem.appendChild(document.createTextNode(src.x))
        if src.l:
            parent.appendChild(document.createTextNode(src.l))
        for v'var i = node.length - 1; i >= 1; i--':  # noqa: unused-local
            stack.push(v'[node[i], elem]')

def unserialize_html(serialized_data, proceed):
    tag_map = serialized_data.tag_map
    tree = serialized_data.tree
    ns_map = serialized_data.ns_map
    html = tag_map[0]
    apply_attributes(html, document.documentElement, ns_map)
    head, body = tree[1], tree[2]  # noqa: unused-local
    clear(document.head, document.body)
    load_required = set()
    proceeded = False

    def hangcheck():
        nonlocal proceeded
        if not proceeded:
            proceeded = True
            proceed()

    def onload():
        nonlocal proceeded
        load_required.discard(this)
        if not load_required.length:
            proceeded = True
            proceed()

    stack = v'[]'
    for v'var i = head.length - 1; i >= 1; i--':
        stack.push(v'[head[i], document.head]')
    process_stack(stack, tag_map, ns_map, load_required, onload)
    bnode = tag_map[body[0]]
    apply_attributes(bnode, document.body, ns_map)
    if bnode.x:
        document.body.appendChild(document.createTextNode(bnode.x))
    for v'var i = body.length - 1; i >= 1; i--':  # noqa: unused-local
        stack.push(v'[body[i], document.body]')
    process_stack(stack, tag_map, ns_map, load_required, onload)
    ev = document.createEvent('Event')
    ev.initEvent('DOMContentLoaded', True, True)
    document.dispatchEvent(ev)
    if load_required.length:
        setTimeout(hangcheck, 5000)
    else:
        proceed = True
        proceed()
