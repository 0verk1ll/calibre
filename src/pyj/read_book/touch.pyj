# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import hash_literals, bound_methods

from read_book.globals import get_boss

def copy_touch(t):
    now = window.performance.now()
    return {'identifier':t.identifier, 'page_x':v'[t.pageX]', 'page_y':v'[t.pageY]', 'viewport_x':v'[t.clientX]', 'viewport_y':v'[t.clientY]',
            'active':True, 'mtime':now, 'ctime':now}

def max_displacement(points):
    ans = 0
    first = points[0]
    if not first?:
        return ans
    for p in points:
        delta = abs(p - first)
        if delta > ans:
            ans = delta
    return ans

def interpret_single_gesture(touch):
    max_x_displacement = max_displacement(touch.viewport_x)
    max_y_displacement = max_displacement(touch.viewport_y)
    if max(max_x_displacement, max_y_displacement) < 25:
        return {'type':'tap'}
    if touch.viewport_y.length < 2:
        return {}
    delta_x = abs(touch.viewport_x[-1] - touch.viewport_x[0])
    delta_y = abs(touch.viewport_y[-1] - touch.viewport_y[0])
    if max(delta_y, delta_x) > 30 and min(delta_x, delta_y)/max(delta_y, delta_x) < 0.35:
        ans = {'type':'swipe'}
        ans.axis = 'vertical' if delta_y > delta_x else 'horizontal'
        pts = touch.viewport_y if ans.axis is 'vertical' else touch.viewport_x
        positive = pts[-1] > pts[0]
        if ans.axis is 'vertical':
            ans.direction = 'down' if positive else 'up'
        else:
            ans.direction = 'right' if positive else 'left'
        return ans
    return {}

class TouchHandler:

    def __init__(self):
        self.ongoing_touches = {}

    @property
    def has_active_touches(self):
        now = window.performance.now()
        expired = v'[]'
        ans = False
        for t in self.ongoing_touches:
            if t.active:
                if now - t.mtime > 3000:
                    expired.push(t.identifier)
                ans = True
                break
        for tid in expired:
            v'delete self.ongoing_touches[tid]'
        return ans

    def handle_touchstart(self, ev):
        ev.preventDefault(), ev.stopPropagation()
        for touch in ev.changedTouches:
            self.ongoing_touches[touch.identifier] = copy_touch(touch)

    def update_touch(self, t, touch):
        t.mtime = window.performance.now()
        t.page_x.push(touch.pageX), t.page_y.push(touch.pageY)
        t.viewport_x.push(touch.clientX), t.viewport_y.push(touch.clientY)

    def handle_touchmove(self, ev):
        ev.preventDefault(), ev.stopPropagation()
        for touch in ev.changedTouches:
            t = self.ongoing_touches[touch.identifier]
            if t:
                self.update_touch(t, touch)
                if len(self.ongoing_touches) is 1:
                    gesture = interpret_single_gesture(t)
                    if gesture?.type is 'swipe':
                        gesture.active = True
                        get_boss().handle_gesture(gesture)


    def handle_touchend(self, ev):
        ev.preventDefault(), ev.stopPropagation()
        for touch in ev.changedTouches:
            t = self.ongoing_touches[touch.identifier]
            if t:
                t.active = False
                self.update_touch(t, touch)
        if not self.has_active_touches:
            touches, self.ongoing_touches = self.ongoing_touches, {}
            self.interpret_gesture(touches)

    def handle_touchcancel(self, ev):
        ev.preventDefault(), ev.stopPropagation()
        for touch in ev.changedTouches:
            v'delete self.ongoing_touches[touch.identifier]'

    def interpret_gesture(self, touches):
        num = len(touches)
        gesture = {}
        if num is 1:
            gesture = interpret_single_gesture(touches[Object.keys(touches)[0]])
        if not gesture?.type:
            return
        if gesture.type is 'tap':
            # TODO: Check for tap on link. Also convert the tap gesture into
            # semantic gestures based on position of tap (next page/previous
            # page/show ui) as these are common to both paged and flow mode.
            pass
        get_boss().handle_gesture(gesture)

touch_handler = TouchHandler()

def create_handlers():
    document.body.addEventListener('touchstart', touch_handler.handle_touchstart, True)
    document.body.addEventListener('touchmove', touch_handler.handle_touchmove, True)
    document.body.addEventListener('touchend', touch_handler.handle_touchend, True)
    document.body.addEventListener('touchcancel', touch_handler.handle_touchcancel, True)
