# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>

from ajax import ajax_send
from dom import set_css, build_rule, clear
from elementmaker import E
from gettext import gettext as _
from modals import error_dialog

from book_list.globals import get_session_data
from widgets import create_button, create_spinner

THUMBNAIL_MAX_WIDTH = 300
THUMBNAIL_MAX_HEIGHT = 400

bv_counter = 0

class BooksView:

    def __init__(self, interface_data):
        nonlocal bv_counter
        bv_counter += 1
        self.interface_data = interface_data
        self.is_fetching = None
        self.shown_book_ids = set()
        self.container_id = 'books-view-' + bv_counter
        # We have to apply the transform on the containing div not the img because of a bug in WebKit
        # that causes img aspect ratios to be messed up on window resize if the transform is specified
        # on the img itself
        style = build_rule('#' + self.container_id + ' .cover_grid > div:hover', transform='scale(1.2)')
        style += build_rule('#' + self.container_id + ' .cover_grid > div:active', transform='scale(2.0)')
        div = E.div(
            id=self.container_id, style='display:block',
            E.style(style),
            E.div(),
            E.div()
        )
        document.body.appendChild(div)
        self.set_view_mode(get_session_data().get('view_mode'))
        self.create_more_button(div)

    def create_more_button(self, div):
        more = div.lastChild
        more.appendChild(create_button(
            _('Show more books'), 'cloud-download', def():self.get_more_books()
        ))
        set_css(more.firstChild, display='block', margin_left='auto', margin_right='auto')
        set_css(more, font_size='1.5rem', padding_top='1.5rem', margin_bottom='1.5rem', width='100%', text_align='center')
        more.appendChild(E.div(
            create_spinner(), '\xa0' + _('Fetching metadata for more books, please wait') + 'â€¦',
            style='margin-left:auto; margin-right:auto; display:none')
        )
        self.update_fetching_status()

    def set_view_mode(self, mode='cover_grid'):
        if self.mode == mode:
            return
        if mode not in v"['cover_grid']":
            mode = 'cover_grid'
        self.mode = mode
        if mode == 'cover_grid':
            self.render_book = self.cover_grid_item.bind(self)
            self.init_grid = self.init_cover_grid.bind(self)
        self.clear()
        self.render_ids()

    @property
    def container(self):
        return document.getElementById(self.container_id)

    @property
    def grid(self):
        return self.container.lastChild.previousSibling

    @property
    def is_visible(self):
        self.container.style.display == 'block'

    @is_visible.setter
    def is_visible(self, val):
        self.container.style.display = 'block' if val else 'none'

    def clear(self):
        # We replace the div entirely so that any styles associated with it are
        # also removed
        c = self.container
        c.removeChild(self.grid)
        c.insertBefore(E.div(), c.lastChild)
        self.shown_book_ids.clear()
        self.init_grid()

    def render_id(self, book_id):
        l = self.shown_book_ids.length
        self.shown_book_ids.add(book_id)
        if l < self.shown_book_ids.length:
            return self.render_book(book_id)

    def render_ids(self, book_ids):
        book_ids = book_ids or self.interface_data['search_result']['book_ids']
        div = self.grid
        for book_id in book_ids:
            child = self.render_id(book_id)
            if child is not None:
                div.appendChild(self.render_book(book_id))

    def update_fetching_status(self):
        c = self.container
        more = c.lastChild
        if self.is_fetching is not None:
            more.firstChild.style.display = 'none'
            more.lastChild.style.display = 'block'
        elif self.interface_data['search_result']['total_num'] > self.shown_book_ids.length:
            more.firstChild.style.display = 'block'
            more.lastChild.style.display = 'none'
        else:
            more.firstChild.style.display = 'none'
            more.lastChild.style.display = 'none'

    def get_more_books(self):
        data = {'offset':self.shown_book_ids.length}
        for key in 'query', 'sort', 'sort_order':
            data[key] = self.interface_data['search_result'][key]
        self.is_fetching = ajax_send('interface-data/more-books', data, self.got_more_books.bind(self),
                                     query={'library_id':self.interface_data.library_id})
        self.update_fetching_status()

    def abort_get_more_books(self):
        if self.is_fetching:
            a, self.is_fetching = self.is_fetching, None
            a.abort()
            self.update_fetching_status()

    def got_more_books(self, end_type, xhr, event):
        if self.is_fetching is None or self.is_fetching is not xhr:
            return  # Fetching was aborted
        self.is_fetching = None
        self.update_fetching_status()
        if end_type == 'load':
            try:
                data = JSON.parse(xhr.responseText)
                for key in data.metadata:
                    self.interface_data.metadata[key] = data.metadata[key]
                if not data.search_result.book_ids:
                    raise Exception('No books ids object in search result from server')
                self.render_ids(data.search_result.book_ids)
                self.interface_data.search_result = data.search_result
            except Exception as err:
                error_dialog(_('Could not get more books'), _('Server returned an invalid response'), err.stack or err.toString())
        elif end_type != 'abort':
            error_dialog(_('Could not get more books'), xhr.error_string)

    # Cover grid {{{

    def init_cover_grid(self):
        div = self.grid
        set_css(div, display='flex', flex_wrap='wrap', justify_content='flex-start', align_items='flex-end', align_content='flex-start', user_select='none')
        div.setAttribute('class', 'cover_grid')

    def cover_grid_item(self, book_id):
        cover_url = str.format('get/thumb/{}/{}?sz={}x{}', book_id, self.interface_data['library_id'], THUMBNAIL_MAX_WIDTH, THUMBNAIL_MAX_HEIGHT)
        metadata = self.interface_data['metadata'][book_id]
        alt = str.format(_('{} by {}'), metadata['title'], metadata['authors'].join(' & '))
        img = E.img(alt=alt, title=alt, data_title=metadata['title'], data_authors=metadata['authors'].join(' & '),
                style='max-width: 100%; max-height: 100%; display: block; width:auto; height:auto')
        img.onerror = def(err):
            img = err.target
            div = img.parentNode
            clear(div)
            div.appendChild(E.div(
                style='position:relative; top:-50%; transform: translateY(50%)',
                E.h2(img.getAttribute('data-title'), style='text-align:center; font-size:larger; font-weight: bold'),
                E.div(_('by'), style='text-align: center'),
                E.h2(img.getAttribute('data-authors'), style='text-align:center; font-size:larger; font-weight: bold')
            ))
            set_css(div, border='dashed 1px currentColor', border_radius='10px')

        img.setAttribute('src', cover_url)
        return E.div(
            style=str.format(('margin: 10px; display: flex; align-content: flex-end; align-items: flex-end; justify-content: space-around;'
                              'width: 21vw; height: 28vw; max-width: {}px; max-height: {}px; min-width: {}px; min-height: {}px; cursor:pointer'),
                             THUMBNAIL_MAX_WIDTH, THUMBNAIL_MAX_HEIGHT, THUMBNAIL_MAX_WIDTH // 2, THUMBNAIL_MAX_HEIGHT // 2),
            data_book_id=str(book_id),
            img
        )

    # }}}
